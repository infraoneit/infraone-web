## Ãœbersicht

Diese Anleitung erklÃ¤rt Schritt fÃ¼r Schritt, wie Keystatic CMS in eine Next.js Website integriert wird, um Blog-Artikel Ã¼ber eine grafische OberflÃ¤che zu erstellen und zu verwalten.

**Was ist Keystatic?**

Keystatic ist ein Git-basiertes Headless CMS, das direkt im Projekt arbeitet. Inhalte werden als JSON/YAML/Markdown-Dateien gespeichert â€“ keine externe Datenbank erforderlich.

---

## 1. Installation

### 1.1 Pakete installieren

```bash
npm install @keystatic/core @keystatic/next
```

### 1.2 Projektstruktur

Nach der Installation benÃ¶tigst du folgende Dateien:

```
projekt/
â”œâ”€â”€ keystatic.config.ts          # Hauptkonfiguration
â”œâ”€â”€ src/
â”‚   â””â”€â”€ app/
â”‚       â”œâ”€â”€ (keystatic)/         # Route Group fÃ¼r CMS
â”‚       â”‚   â””â”€â”€ keystatic/
â”‚       â”‚       â””â”€â”€ [[...params]]/
â”‚       â”‚           â””â”€â”€ page.tsx # CMS-Seite
â”‚       â””â”€â”€ (website)/           # Route Group fÃ¼r Website
â”‚           â””â”€â”€ blog/
â”‚               â””â”€â”€ [slug]/
â”‚                   â””â”€â”€ page.tsx # Blog-Detail
â”œâ”€â”€ content/
â”‚   â””â”€â”€ blog/                    # Hier speichert Keystatic die Inhalte
```

---

## 2. Keystatic Konfiguration

### 2.1 Datei: keystatic.config.ts

Diese Datei definiert alle Collections (z.B. Blog-Artikel) und Singletons (z.B. Einstellungen).

```typescript
import { config, fields, collection } from '@keystatic/core';

export default config({
    storage: {
        kind: 'local',  // Speichert lokal im Dateisystem
    },
    ui: {
        brand: {
            name: 'Mein CMS',  // Name im CMS-Header
        },
    },
    collections: {
        blog: collection({
            label: 'Blog Artikel',
            slugField: 'slug',
            path: 'content/blog/*',
            entryLayout: 'content',  // WICHTIG: ErmÃ¶glicht Ordnerstruktur
            format: { data: 'json' },
            schema: {
                // Felder hier definieren...
            },
        }),
    },
});
```

### 2.2 Wichtige Konfigurationsoptionen

| Option | Beschreibung |
|--------|--------------|
| `storage.kind` | `'local'` fÃ¼r lokale Entwicklung, `'github'` fÃ¼r GitHub-Integration |
| `slugField` | Welches Feld als URL-Slug verwendet wird |
| `path` | Wo die Content-Dateien gespeichert werden |
| `entryLayout` | `'content'` = Ordnerstruktur mit separater Markdoc-Datei |
| `format.data` | `'json'` oder `'yaml'` fÃ¼r Metadaten |

---

## 3. Blog Collection Schema

### 3.1 VollstÃ¤ndiges Schema-Beispiel

```typescript
schema: {
    // Grundinformationen
    slug: fields.text({ 
        label: 'URL-Slug',
        description: 'URL-freundlicher Name (z.B. "mein-artikel")',
    }),
    title: fields.text({ 
        label: 'Artikel-Titel',
        validation: { isRequired: true },
    }),
    excerpt: fields.text({ 
        label: 'Kurzbeschreibung',
        multiline: true,
        validation: { isRequired: true },
    }),

    // Kategorisierung
    category: fields.select({
        label: 'Kategorie',
        options: [
            { label: 'IT-Wissen', value: 'it-wissen' },
            { label: 'Netzwerke', value: 'netzwerke' },
        ],
        defaultValue: 'it-wissen',
    }),
    keywords: fields.array(
        fields.text({ label: 'Schlagwort' }),
        { label: 'SchlagwÃ¶rter' }
    ),

    // Titelbild
    featuredImage: fields.image({
        label: 'Titelbild',
        directory: 'public/images/blog',
        publicPath: '/images/blog/',
    }),

    // Datum & Lesezeit
    publishDate: fields.date({ 
        label: 'VerÃ¶ffentlichungsdatum',
        defaultValue: { kind: 'today' },
    }),
    readingTime: fields.text({ 
        label: 'Lesezeit',
        defaultValue: '5 Min.',
    }),

    // Artikelinhalt (Rich-Text-Editor)
    content: fields.markdoc({
        label: 'Artikelinhalt',
        options: {
            heading: [2, 3, 4],
            bold: true,
            italic: true,
            link: true,
            blockquote: true,
            orderedList: true,
            unorderedList: true,
            code: true,
            codeBlock: true,
            table: true,
            image: {
                directory: 'public/images/blog',
                publicPath: '/images/blog/',
            },
        },
    }),

    // SEO
    metaTitle: fields.text({ label: 'SEO: Meta-Titel' }),
    metaDescription: fields.text({ 
        label: 'SEO: Meta-Beschreibung',
        multiline: true,
    }),
}
```

### 3.2 Feldtypen-Ãœbersicht

| Feldtyp | Verwendung |
|---------|------------|
| `fields.text()` | Einfache Textfelder |
| `fields.text({ multiline: true })` | Mehrzeilige Textfelder |
| `fields.select()` | Dropdown-Auswahl |
| `fields.array()` | Listen (z.B. Tags) |
| `fields.image()` | Bild-Upload |
| `fields.date()` | Datumsauswahl |
| `fields.markdoc()` | Rich-Text-Editor |
| `fields.checkbox()` | Ja/Nein-Auswahl |
| `fields.integer()` | Ganzzahlen |

---

## 4. Dateistruktur fÃ¼r Blog-Artikel

### 4.1 So speichert Keystatic die Daten

Mit `entryLayout: 'content'` erstellt Keystatic folgende Struktur:

```
content/blog/
â”œâ”€â”€ mein-artikel.json           # Metadaten (Titel, Kategorie, etc.)
â””â”€â”€ mein-artikel/
    â””â”€â”€ content.mdoc            # Artikelinhalt (Markdoc)
```

### 4.2 Beispiel: mein-artikel.json

```json
{
  "title": "Mein erster Artikel",
  "excerpt": "Eine kurze Beschreibung des Artikels.",
  "category": "it-wissen",
  "keywords": ["Keyword 1", "Keyword 2"],
  "featuredImage": "/images/blog/mein-artikel/titelbild.png",
  "publishDate": "2026-01-22",
  "readingTime": "5 Min.",
  "metaTitle": "Mein Artikel | Meine Website",
  "metaDescription": "SEO-Beschreibung hier."
}
```

### 4.3 Beispiel: mein-artikel/content.mdoc

```markdown
## Einleitung

Hier beginnt der **Artikelinhalt** mit Markdoc-Formatierung.

### UnterÃ¼berschrift

- AufzÃ¤hlung 1
- AufzÃ¤hlung 2

1. Nummerierte Liste
2. Zweiter Punkt

Ein [Link](https://example.com) im Text.
```

---

## 5. CMS-Route einrichten (Next.js App Router)

### 5.1 Route Groups verwenden

Um das CMS vom Website-Layout zu trennen, verwende Route Groups:

```
src/app/
â”œâ”€â”€ (keystatic)/              # CMS ohne Website-Layout
â”‚   â””â”€â”€ keystatic/
â”‚       â””â”€â”€ [[...params]]/
â”‚           â””â”€â”€ page.tsx
â”œâ”€â”€ (website)/                # Website mit Header/Footer
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ blog/
â”‚       â””â”€â”€ [slug]/
â”‚           â””â”€â”€ page.tsx
â””â”€â”€ layout.tsx                # Root Layout (minimal)
```

### 5.2 Datei: src/app/(keystatic)/keystatic/[[...params]]/page.tsx

```typescript
import { makePage } from '@keystatic/next/ui/app';
import keystaticConfig from '../../../../../keystatic.config';

export default makePage(keystaticConfig);
```

### 5.3 Root Layout anpassen

Das Root Layout (`src/app/layout.tsx`) sollte minimal sein:

```typescript
export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="de">
            <body>{children}</body>
        </html>
    );
}
```

Header und Footer gehÃ¶ren in `src/app/(website)/layout.tsx`.

---

## 6. Blog-Daten im Frontend laden

### 6.1 Utility-Funktion: src/lib/blog.ts

```typescript
import fs from 'fs';
import path from 'path';

export interface BlogPost {
    slug: string;
    title: string;
    excerpt: string;
    content: string;
    date: string;
    category: string;
    keywords: string[];
    readingTime: string;
    featuredImage?: string;
}

// Markdoc-Inhalt aus Datei lesen
function readContent(slug: string): string {
    const mdocPath = path.join(
        process.cwd(), 
        'content', 'blog', slug, 'content.mdoc'
    );
    if (fs.existsSync(mdocPath)) {
        return fs.readFileSync(mdocPath, 'utf-8');
    }
    return '';
}

// Alle Blog-Posts laden
export async function getAllBlogPosts(): Promise<BlogPost[]> {
    const blogDir = path.join(process.cwd(), 'content', 'blog');
    const files = fs.readdirSync(blogDir);
    
    const posts: BlogPost[] = [];
    
    for (const file of files) {
        if (file.endsWith('.json')) {
            const slug = file.replace('.json', '');
            const jsonPath = path.join(blogDir, file);
            const data = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));
            
            posts.push({
                slug,
                title: data.title,
                excerpt: data.excerpt,
                content: readContent(slug),
                date: data.publishDate,
                category: data.category,
                keywords: data.keywords || [],
                readingTime: data.readingTime,
                featuredImage: data.featuredImage,
            });
        }
    }
    
    // Nach Datum sortieren (neueste zuerst)
    return posts.sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
    );
}

// Einzelnen Post laden
export async function getBlogPost(slug: string): Promise<BlogPost | null> {
    const posts = await getAllBlogPosts();
    return posts.find(p => p.slug === slug) || null;
}
```

### 6.2 In der Blog-Seite verwenden

```typescript
// src/app/(website)/blog/[slug]/page.tsx
import { getBlogPost, getAllBlogPosts } from '@/lib/blog';
import { notFound } from 'next/navigation';
import { MarkdownRenderer } from '@/components/ui/MarkdownRenderer';

export async function generateStaticParams() {
    const posts = await getAllBlogPosts();
    return posts.map(post => ({ slug: post.slug }));
}

export default async function BlogPostPage({ 
    params 
}: { 
    params: Promise<{ slug: string }> 
}) {
    const { slug } = await params;
    const post = await getBlogPost(slug);

    if (!post) {
        notFound();
    }

    return (
        <article>
            <h1>{post.title}</h1>
            <MarkdownRenderer content={post.content} />
        </article>
    );
}
```

---

## 7. Markdown/Markdoc rendern

### 7.1 Komponente: src/components/ui/MarkdownRenderer.tsx

```typescript
"use client";

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkHtml from 'remark-html';

interface Props {
    content: string;
}

export function MarkdownRenderer({ content }: Props) {
    const html = unified()
        .use(remarkParse)
        .use(remarkHtml)
        .processSync(content)
        .toString();

    return (
        <div 
            className="prose prose-lg max-w-none"
            dangerouslySetInnerHTML={{ __html: html }}
        />
    );
}
```

### 7.2 Pakete installieren

```bash
npm install unified remark-parse remark-html
```

---

## 8. HÃ¤ufige Probleme & LÃ¶sungen

### Problem: Collection zeigt keine EintrÃ¤ge

**Ursache:** Falsche Dateistruktur.

**LÃ¶sung:** Mit `entryLayout: 'content'` muss die Struktur so sein:

```
content/blog/
â”œâ”€â”€ artikel-slug.json           # JSON im Hauptordner
â””â”€â”€ artikel-slug/
    â””â”€â”€ content.mdoc            # Markdoc im Unterordner
```

NICHT so:

```
content/blog/
â””â”€â”€ artikel-slug/
    â”œâ”€â”€ index.json              # FALSCH!
    â””â”€â”€ content.mdoc
```

### Problem: Bilder werden nicht angezeigt

**Ursache:** Falscher `publicPath`.

**LÃ¶sung:** `directory` und `publicPath` mÃ¼ssen zusammenpassen:

```typescript
featuredImage: fields.image({
    directory: 'public/images/blog',  // Wo gespeichert wird
    publicPath: '/images/blog/',      // URL-Pfad (ohne 'public')
}),
```

### Problem: CMS hat Website-Layout

**Ursache:** Keystatic-Route nicht in eigener Route Group.

**LÃ¶sung:** Route Groups verwenden:

```
src/app/
â”œâ”€â”€ (keystatic)/    # Ohne Layout
â””â”€â”€ (website)/      # Mit Header/Footer
```

---

## 9. Checkliste fÃ¼r neue Blog-Artikel

1. Im CMS unter `/keystatic` einloggen
2. "Blog Artikel" â†’ "Neuer Eintrag"
3. Alle Pflichtfelder ausfÃ¼llen:
   - Titel (H1)
   - Kurzbeschreibung
   - Kategorie wÃ¤hlen
4. Optional:
   - Titelbild hochladen
   - SchlagwÃ¶rter hinzufÃ¼gen
   - SEO-Felder ausfÃ¼llen
5. Artikelinhalt im Rich-Text-Editor schreiben
6. "Speichern" klicken
7. Website neu laden â€“ Artikel erscheint automatisch

---

## 10. Zusammenfassung

| Komponente | Datei/Ort |
|------------|-----------|
| Keystatic Config | `keystatic.config.ts` |
| CMS-Route | `src/app/(keystatic)/keystatic/[[...params]]/page.tsx` |
| Blog-Inhalte | `content/blog/[slug].json` + `content/blog/[slug]/content.mdoc` |
| Daten laden | `src/lib/blog.ts` |
| Markdown rendern | `src/components/ui/MarkdownRenderer.tsx` |
| Blog-Seite | `src/app/(website)/blog/[slug]/page.tsx` |

**Wichtigste Erkenntnisse:**

1. `entryLayout: 'content'` aktiviert Ordnerstruktur fÃ¼r Rich-Text
2. JSON-Datei im Hauptordner, Markdoc in Unterordner
3. Route Groups trennen CMS vom Website-Layout
4. Bilder: `directory` = Speicherort, `publicPath` = URL

---

## 11. Singletons fÃ¼r Service-/Leistungsseiten

Im Gegensatz zu Collections (fÃ¼r beliebig viele EintrÃ¤ge wie Blog-Artikel) sind **Singletons** fÃ¼r einzelne, einzigartige Inhalte gedacht â€“ z.B. eine IT-Support-Hauptseite, Site-Settings oder den Footer.

### 11.1 Collection vs. Singleton

| Eigenschaft | Collection | Singleton |
|------------|------------|-----------|
| **Verwendung** | Viele gleichartige EintrÃ¤ge | Einzelne, einzigartige Seite |
| **Beispiele** | Blog-Artikel, Testimonials, Team | IT-Support-Seite, Footer, Settings |
| **Datei-Struktur** | `content/blog/*.json` | `content/leistungen/it-support.json` |
| **Import** | `collection()` | `singleton()` |

### 11.2 Singleton in keystatic.config.ts definieren

```typescript
import { config, fields, collection, singleton } from '@keystatic/core';

export default config({
    // ...
    singletons: {
        itSupport: singleton({
            label: 'Leistungen â†’ IT-Support',  // Name im CMS
            path: 'content/leistungen/it-support',  // Speicherort
            format: { data: 'json' },  // Dateiformat
            schema: {
                // Schema-Definition hier...
            },
        }),
    },
    // ...
});
```

---

## 12. Schema-Design mit logischen Gruppen

FÃ¼r Ã¼bersichtliche Eingabemasken gruppiere zusammengehÃ¶rige Felder mit `fields.object()`.

### 12.1 Grundstruktur mit Sections

```typescript
schema: {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ðŸ“Œ SECTION: HERO-BEREICH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    heroSection: fields.object({
        headline: fields.text({
            label: 'Ãœberschrift (H1)',
            description: 'HauptÃ¼berschrift der Seite',
            validation: { isRequired: true },
        }),
        subheadline: fields.text({
            label: 'Unterzeile',
            description: 'z.B. "Sofort. Schweizweit."',
        }),
        description: fields.text({
            label: 'Beschreibungstext',
            multiline: true,
        }),
        heroImage: fields.image({
            label: 'Hero-Bild',
            directory: 'public/images/leistungen',
            publicPath: '/images/leistungen/',
        }),
    }, {
        label: 'ðŸ“Œ HERO-BEREICH',
        description: 'Der oberste Bereich der Seite',
    }),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ðŸ’° SECTION: PREISE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pricingSection: fields.object({
        // ... weitere Felder
    }, {
        label: 'ðŸ’° PREISE & LEISTUNGEN',
    }),
}
```

### 12.2 Warum Emojis in Labels?

Emojis machen die CMS-Navigation intuitiver:

- ðŸ“Œ = Hero/Header
- ðŸ’° = Preise/Kosten
- ðŸ“ = Regionen/Standorte
- â“ = FAQs
- ðŸš¨ = Call-to-Action/Notfall
- ðŸ” = SEO
- âš™ï¸ = Technische Einstellungen

---

## 13. Erweiterte Feldtypen

### 13.1 Select (Dropdown)

```typescript
gridColumns: fields.select({
    label: 'Kacheln pro Reihe',
    description: 'Layout der Preis-Karten',
    options: [
        { label: '2 Kacheln pro Reihe', value: '2' },
        { label: '3 Kacheln pro Reihe', value: '3' },
        { label: '4 Kacheln pro Reihe', value: '4' },
    ],
    defaultValue: '4',
}),
```

### 13.2 Multiselect (Mehrfachauswahl)

```typescript
areaServed: fields.multiselect({
    label: 'Bediente Regionen',
    description: 'In welchen Regionen wird angeboten?',
    options: [
        { label: 'Schweiz (ganze)', value: 'Schweiz' },
        { label: 'Winterthur', value: 'Winterthur' },
        { label: 'ZÃ¼rich', value: 'ZÃ¼rich' },
        // ... weitere
    ],
    defaultValue: ['Schweiz', 'Winterthur', 'ZÃ¼rich'],
}),
```

### 13.3 Checkbox

```typescript
includeFaqSchema: fields.checkbox({
    label: 'FAQ Schema generieren',
    description: 'FAQs als Structured Data ausgeben?',
    defaultValue: true,
}),
```

### 13.4 Array mit Objekten (fÃ¼r Listen)

```typescript
priceCards: fields.array(
    fields.object({
        title: fields.text({ label: 'Titel' }),
        description: fields.text({ label: 'Beschreibung', multiline: true }),
        price: fields.text({ label: 'Preis' }),
        icon: fields.select({
            label: 'Icon',
            options: [
                { label: 'ðŸ“ž Telefon', value: 'phone' },
                { label: 'ðŸ–¥ï¸ Monitor', value: 'monitor' },
                { label: 'ðŸ“ Pin', value: 'mappin' },
                // ... weitere Icons
            ],
            defaultValue: 'phone',
        }),
    }),
    {
        label: 'Preis-Karten',
        description: 'Beliebig viele Karten hinzufÃ¼gen',
        itemLabel: props => props.fields.title.value || 'Neue Karte',
    }
),
```

### 13.5 File Upload (fÃ¼r Downloads)

```typescript
downloadFile: fields.file({
    label: 'Download-Datei',
    description: 'ZIP, EXE, PDF etc.',
    directory: 'public/downloads',
    publicPath: '/downloads/',
}),
downloadFileName: fields.text({
    label: 'Download-Dateiname',
    description: 'Wie soll die Datei beim Download heissen?',
}),
```

---

## 14. Button mit Link oder Download

### 14.1 Schema-Definition

```typescript
secondaryButtonText: fields.text({
    label: 'Button Text',
    defaultValue: 'Remote-Support starten',
}),
secondaryButtonAction: fields.select({
    label: 'Button Aktion',
    options: [
        { label: 'ðŸ”— Link Ã¶ffnen', value: 'link' },
        { label: 'ðŸ“¥ Datei herunterladen', value: 'download' },
    ],
    defaultValue: 'link',
}),
secondaryButtonUrl: fields.text({
    label: 'URL (fÃ¼r Link)',
    description: 'z.B. "/kontakt" oder "https://example.com"',
}),
secondaryButtonFile: fields.file({
    label: 'Datei (fÃ¼r Download)',
    directory: 'public/downloads',
    publicPath: '/downloads/',
}),
secondaryButtonFileName: fields.text({
    label: 'Download-Dateiname',
    description: 'z.B. "AnyDesk.exe"',
}),
```

### 14.2 Frontend-Implementierung

```typescript
// Daten aus CMS
const isDownload = heroSection.secondaryButtonAction === 'download';
const buttonHref = isDownload 
    ? heroSection.secondaryButtonFile || '#' 
    : heroSection.secondaryButtonUrl || '#';
const isExternalLink = buttonHref.startsWith('http');
const downloadFileName = heroSection.secondaryButtonFileName;

// JSX
<a
    href={buttonHref}
    target={isExternalLink ? '_blank' : undefined}
    rel={isExternalLink ? 'noopener noreferrer' : undefined}
    {...(isDownload ? { download: downloadFileName || '' } : {})}
>
    {isDownload ? <DownloadIcon /> : <LinkIcon />}
    {heroSection.secondaryButtonText}
</a>
```

---

## 15. Icon-Mapping im Frontend

### 15.1 Icon-Map definieren

```typescript
import { 
    Phone, Monitor, MapPin, Users, Shield, Cloud, 
    Wrench, Zap, Headphones, Globe, Mail, Server, 
    HardDrive, BarChart, Lock, Settings, Smartphone, 
    Laptop, Printer, Wifi 
} from 'lucide-react';

const iconMap: Record<string, React.ReactNode> = {
    phone: <Phone className="w-8 h-8" />,
    monitor: <Monitor className="w-8 h-8" />,
    mappin: <MapPin className="w-8 h-8" />,
    users: <Users className="w-8 h-8" />,
    shield: <Shield className="w-8 h-8" />,
    cloud: <Cloud className="w-8 h-8" />,
    wrench: <Wrench className="w-8 h-8" />,
    zap: <Zap className="w-8 h-8" />,
    headphones: <Headphones className="w-8 h-8" />,
    globe: <Globe className="w-8 h-8" />,
    mail: <Mail className="w-8 h-8" />,
    server: <Server className="w-8 h-8" />,
    harddrive: <HardDrive className="w-8 h-8" />,
    barchart: <BarChart className="w-8 h-8" />,
    lock: <Lock className="w-8 h-8" />,
    settings: <Settings className="w-8 h-8" />,
    smartphone: <Smartphone className="w-8 h-8" />,
    laptop: <Laptop className="w-8 h-8" />,
    printer: <Printer className="w-8 h-8" />,
    wifi: <Wifi className="w-8 h-8" />,
};
```

### 15.2 Icon aus CMS-Daten rendern

```typescript
{priceCards.map((card, index) => (
    <div key={index}>
        {iconMap[card.icon] || <Monitor className="w-8 h-8" />}
        <h3>{card.title}</h3>
        <p>{card.description}</p>
        <p>{card.price}</p>
    </div>
))}
```

---

## 16. Grid-Layout dynamisch steuern

### 16.1 Grid-Spalten-Mapping

```typescript
const gridColumnsMap: Record<string, string> = {
    '2': 'md:grid-cols-2 lg:grid-cols-2',
    '3': 'md:grid-cols-2 lg:grid-cols-3',
    '4': 'md:grid-cols-2 lg:grid-cols-4',
};
```

### 16.2 Verwendung im JSX

```typescript
<div className={`grid ${gridColumnsMap[pricingSection.gridColumns || '4']} gap-6`}>
    {pricingSection.priceCards.map((card, index) => (
        // Karten hier...
    ))}
</div>
```

---

## 17. Singleton-Daten im Frontend laden

### 17.1 Utility-Funktion: src/lib/leistungen.ts

```typescript
import { createReader } from '@keystatic/core/reader';
import keystaticConfig from '../../keystatic.config';

// Reader-Instanz (cached)
let readerInstance: ReturnType<typeof createReader> | null = null;

async function getReader() {
    if (!readerInstance) {
        readerInstance = createReader(process.cwd(), keystaticConfig);
    }
    return readerInstance;
}

// IT-Support Daten laden
export async function getITSupportData() {
    try {
        const reader = await getReader();
        const itSupport = await reader.singletons.itSupport.read();
        return itSupport;
    } catch (error) {
        console.error('Error reading IT Support data:', error);
        return null;
    }
}
```

### 17.2 In der Page-Komponente verwenden

```typescript
// src/app/(website)/it-support/page.tsx
import { getITSupportData } from '@/lib/leistungen';

export default async function ITSupportPage() {
    const cmsData = await getITSupportData();
    
    // Fallback-Daten falls CMS leer
    const heroSection = cmsData?.heroSection ?? {
        headline: 'Informatik-Support',
        subheadline: 'Sofort. Schweizweit.',
        description: 'Standard-Beschreibung...',
        // ... weitere Defaults
    };
    
    return (
        <>
            <h1>{heroSection.headline}</h1>
            <p>{heroSection.subheadline}</p>
            {/* ... */}
        </>
    );
}
```

---

## 18. Structured Data aus CMS generieren

### 18.1 Schema.org Helper-Funktionen

```typescript
// src/lib/seo/schema.ts

export function generateProfessionalServiceSchema(
    slug: string,
    name: string,
    url: string,
    areaServed: string[] = ['Schweiz']
) {
    return {
        '@context': 'https://schema.org',
        '@type': 'ProfessionalService',
        name,
        url,
        areaServed: areaServed.map(area => ({
            '@type': 'Place',
            name: area,
        })),
        // ... weitere Properties
    };
}

export function generateFAQSchema(faqs: { question: string; answer: string }[]) {
    return {
        '@context': 'https://schema.org',
        '@type': 'FAQPage',
        mainEntity: faqs.map(faq => ({
            '@type': 'Question',
            name: faq.question,
            acceptedAnswer: {
                '@type': 'Answer',
                text: faq.answer,
            },
        })),
    };
}
```

### 18.2 Im Page verwenden

```typescript
// Daten aus CMS
const structuredData = cmsData?.structuredDataSection ?? {
    schemaType: 'ProfessionalService',
    areaServed: ['Schweiz'],
    includeFaqSchema: true,
};

// Schema generieren
const mainSchema = structuredData.schemaType === 'LocalBusiness'
    ? generateLocalBusinessSchema(...)
    : generateProfessionalServiceSchema(...);

const faqSchema = structuredData.includeFaqSchema 
    ? generateFAQSchema(faqsSection.faqs) 
    : null;

// Im JSX
return (
    <>
        <script 
            type="application/ld+json" 
            dangerouslySetInnerHTML={{ __html: JSON.stringify(mainSchema) }} 
        />
        {faqSchema && (
            <script 
                type="application/ld+json" 
                dangerouslySetInnerHTML={{ __html: JSON.stringify(faqSchema) }} 
            />
        )}
        {/* Page content... */}
    </>
);
```

---

## 19. VollstÃ¤ndiges Beispiel: IT-Support Singleton

### 19.1 Dateistruktur

```
content/
â””â”€â”€ leistungen/
    â””â”€â”€ it-support.json    # Alle Daten in einer JSON-Datei
```

### 19.2 Beispiel-JSON (it-support.json)

```json
{
  "heroSection": {
    "categoryLabel": "IT-SUPPORT & COMPUTERHILFE",
    "headline": "Informatik-Support",
    "subheadline": "Sofort. Schweizweit.",
    "description": "Professioneller IT-Support...",
    "heroImage": "/images/leistungen/hero.png",
    "primaryButtonText": "052 222 18 18",
    "primaryButtonHref": "tel:+41522221818",
    "secondaryButtonText": "Remote-Support starten",
    "secondaryButtonAction": "link",
    "secondaryButtonUrl": "https://anydesk.com/..."
  },
  "pricingSection": {
    "sectionTitle": "IT-Support Preise",
    "gridColumns": "4",
    "priceCards": [
      {
        "title": "Telefonischer Support",
        "description": "Schnelle Hilfe...",
        "price": "CHF 120.â€“/h",
        "icon": "phone"
      }
    ]
  },
  "faqsSection": {
    "sectionTitle": "HÃ¤ufige Fragen",
    "faqs": [
      {
        "question": "Wie schnell erhalte ich Hilfe?",
        "answer": "In der Regel innerhalb von 30 Minuten."
      }
    ]
  },
  "seoSection": {
    "metaTitle": "IT-Support Schweiz | InfraOne",
    "metaDescription": "Professioneller IT-Support..."
  },
  "structuredDataSection": {
    "schemaType": "ProfessionalService",
    "areaServed": ["Schweiz", "Winterthur", "ZÃ¼rich"],
    "includeFaqSchema": true
  }
}
```

---

## 20. Checkliste: Neues Singleton erstellen

1. **keystatic.config.ts**
   - Singleton unter `singletons: {}` definieren
   - Label und Path setzen
   - Schema mit logischen Gruppen (`fields.object`) strukturieren
   - Emojis in Labels fÃ¼r bessere Navigation

2. **Utility-Funktion erstellen (src/lib/)**
   - `getXYZData()` Funktion mit Keystatic Reader
   - Error-Handling implementieren

3. **Page-Komponente anpassen**
   - Daten mit `await getXYZData()` laden
   - Fallback-Daten definieren
   - Dynamisch rendern

4. **Optionale Erweiterungen**
   - Icon-Mapping fÃ¼r Select-Felder
   - Grid-Layout-Steuerung
   - Button-Aktionen (Link/Download)
   - Structured Data Integration

---

## 21. Zusammenfassung: Singleton vs. Collection

| Aspekt | Blog (Collection) | IT-Support (Singleton) |
|--------|-------------------|------------------------|
| **Zweck** | Viele Artikel | Eine Seite |
| **Speicherung** | `content/blog/*.json` | `content/leistungen/it-support.json` |
| **Content-Datei** | Separater Ordner mit content.mdoc | Alles in einer JSON |
| **entryLayout** | `'content'` (fÃ¼r Markdoc) | Nicht benÃ¶tigt |
| **Laden** | `getAllBlogPosts()` | `getITSupportData()` |
| **Reader-Aufruf** | `reader.collections.blog.all()` | `reader.singletons.itSupport.read()` |

**Wichtig:** Singletons haben KEINEN `entryLayout: 'content'` â€“ alle Daten liegen in einer JSON-Datei.
